# Deployment Guide

This guide covers different deployment scenarios for your FastAPI application generated by the boilerplate generator.

## Table of Contents

- [Local Development](#local-development)
- [Docker Deployment](#docker-deployment)
- [Production Deployment](#production-deployment)
- [Cloud Deployment](#cloud-deployment)
- [Environment Configuration](#environment-configuration)
- [Security Considerations](#security-considerations)

## Local Development

### Prerequisites

- Python 3.8+
- PostgreSQL 12+
- Redis (optional)

### Setup Steps

1. **Clone and setup the project:**
   ```bash
   cd your-project-directory
   python -m venv venv
   source venv/bin/activate  # On Windows: venv\Scripts\activate
   pip install -r requirements.txt
   ```

2. **Configure environment:**
   ```bash
   cp .env.example .env
   # Edit .env with your local settings
   ```

3. **Setup database:**
   ```bash
   # Create database
   createdb your_database_name
   
   # Run migrations
   alembic upgrade head
   ```

4. **Run the application:**
   ```bash
   python main.py
   # Or with uvicorn directly
   uvicorn main:app --reload --host 0.0.0.0 --port 8000
   ```

## Docker Deployment

### Development with Docker

```bash
# Build and run with docker-compose
docker-compose up --build

# Run in background
docker-compose up -d

# View logs
docker-compose logs -f app

# Stop services
docker-compose down
```

### Production Docker Setup

1. **Create production docker-compose:**
   ```yaml
   # docker-compose.prod.yml
   version: '3.8'
   
   services:
     app:
       build: 
         context: .
         dockerfile: Dockerfile.prod
       ports:
         - "8000:8000"
       environment:
         - DEBUG=false
         - POSTGRES_SERVER=db
       depends_on:
         - db
         - redis
       restart: unless-stopped
       
     db:
       image: postgres:15
       environment:
         - POSTGRES_USER=${POSTGRES_USER}
         - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
         - POSTGRES_DB=${POSTGRES_DB}
       volumes:
         - postgres_data:/var/lib/postgresql/data
       restart: unless-stopped
         
     redis:
       image: redis:7-alpine
       restart: unless-stopped
       
     nginx:
       image: nginx:alpine
       ports:
         - "80:80"
         - "443:443"
       volumes:
         - ./nginx.conf:/etc/nginx/nginx.conf
         - ./ssl:/etc/nginx/ssl
       depends_on:
         - app
       restart: unless-stopped
   
   volumes:
     postgres_data:
   ```

2. **Create production Dockerfile:**
   ```dockerfile
   # Dockerfile.prod
   FROM python:3.11-slim as builder
   
   WORKDIR /app
   
   # Install system dependencies
   RUN apt-get update && apt-get install -y \
       gcc \
       && rm -rf /var/lib/apt/lists/*
   
   # Install Python dependencies
   COPY requirements.txt .
   RUN pip install --no-cache-dir -r requirements.txt
   
   # Production stage
   FROM python:3.11-slim
   
   WORKDIR /app
   
   # Copy installed packages from builder
   COPY --from=builder /usr/local/lib/python3.11/site-packages /usr/local/lib/python3.11/site-packages
   COPY --from=builder /usr/local/bin /usr/local/bin
   
   # Copy application
   COPY . .
   
   # Create non-root user
   RUN useradd --create-home --shell /bin/bash app
   RUN chown -R app:app /app
   USER app
   
   # Health check
   HEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 \
     CMD curl -f http://localhost:8000/health || exit 1
   
   EXPOSE 8000
   
   CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "8000"]
   ```

## Production Deployment

### VPS/Server Deployment

1. **Server setup:**
   ```bash
   # Update system
   sudo apt update && sudo apt upgrade -y
   
   # Install dependencies
   sudo apt install -y python3 python3-pip python3-venv postgresql redis-server nginx certbot
   
   # Create application user
   sudo useradd -m -s /bin/bash appuser
   sudo usermod -aG sudo appuser
   ```

2. **Application setup:**
   ```bash
   # Switch to app user
   sudo su - appuser
   
   # Clone repository
   git clone <your-repo-url> /home/appuser/app
   cd /home/appuser/app
   
   # Setup Python environment
   python3 -m venv venv
   source venv/bin/activate
   pip install -r requirements.txt
   
   # Setup environment
   cp .env.example .env
   # Edit .env with production settings
   
   # Run migrations
   alembic upgrade head
   ```

3. **Systemd service:**
   ```ini
   # /etc/systemd/system/fastapi-app.service
   [Unit]
   Description=FastAPI application
   After=network.target
   
   [Service]
   Type=simple
   User=appuser
   WorkingDirectory=/home/appuser/app
   Environment=PATH=/home/appuser/app/venv/bin
   ExecStart=/home/appuser/app/venv/bin/uvicorn main:app --host 0.0.0.0 --port 8000
   Restart=always
   RestartSec=10
   
   [Install]
   WantedBy=multi-user.target
   ```

4. **Nginx configuration:**
   ```nginx
   # /etc/nginx/sites-available/fastapi-app
   server {
       listen 80;
       server_name your-domain.com;
       
       location / {
           proxy_pass http://127.0.0.1:8000;
           proxy_set_header Host $host;
           proxy_set_header X-Real-IP $remote_addr;
           proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
           proxy_set_header X-Forwarded-Proto $scheme;
       }
   }
   ```

5. **Enable and start services:**
   ```bash
   # Enable services
   sudo systemctl enable fastapi-app
   sudo systemctl enable nginx
   
   # Start services
   sudo systemctl start fastapi-app
   sudo systemctl start nginx
   
   # Enable nginx site
   sudo ln -s /etc/nginx/sites-available/fastapi-app /etc/nginx/sites-enabled/
   sudo nginx -t
   sudo systemctl reload nginx
   ```

6. **SSL with Let's Encrypt:**
   ```bash
   sudo certbot --nginx -d your-domain.com
   ```

## Cloud Deployment

### AWS ECS

1. **Create ECR repository:**
   ```bash
   aws ecr create-repository --repository-name your-app-name
   ```

2. **Build and push image:**
   ```bash
   # Get login token
   aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin <account-id>.dkr.ecr.us-east-1.amazonaws.com
   
   # Build and tag image
   docker build -t your-app-name .
   docker tag your-app-name:latest <account-id>.dkr.ecr.us-east-1.amazonaws.com/your-app-name:latest
   
   # Push image
   docker push <account-id>.dkr.ecr.us-east-1.amazonaws.com/your-app-name:latest
   ```

3. **ECS Task Definition:**
   ```json
   {
     "family": "your-app-name",
     "networkMode": "awsvpc",
     "requiresCompatibilities": ["FARGATE"],
     "cpu": "256",
     "memory": "512",
     "executionRoleArn": "arn:aws:iam::<account-id>:role/ecsTaskExecutionRole",
     "containerDefinitions": [
       {
         "name": "app",
         "image": "<account-id>.dkr.ecr.us-east-1.amazonaws.com/your-app-name:latest",
         "portMappings": [
           {
             "containerPort": 8000,
             "protocol": "tcp"
           }
         ],
         "environment": [
           {
             "name": "DEBUG",
             "value": "false"
           }
         ],
         "logConfiguration": {
           "logDriver": "awslogs",
           "options": {
             "awslogs-group": "/ecs/your-app-name",
             "awslogs-region": "us-east-1",
             "awslogs-stream-prefix": "ecs"
           }
         }
       }
     ]
   }
   ```

### Google Cloud Run

1. **Build and deploy:**
   ```bash
   # Build image
   gcloud builds submit --tag gcr.io/PROJECT-ID/your-app-name
   
   # Deploy to Cloud Run
   gcloud run deploy your-app-name \
     --image gcr.io/PROJECT-ID/your-app-name \
     --platform managed \
     --region us-central1 \
     --allow-unauthenticated
   ```

### Heroku

1. **Heroku setup:**
   ```bash
   # Login and create app
   heroku login
   heroku create your-app-name
   
   # Add PostgreSQL addon
   heroku addons:create heroku-postgresql:hobby-dev
   
   # Add Redis addon
   heroku addons:create heroku-redis:hobby-dev
   
   # Set environment variables
   heroku config:set DEBUG=false
   heroku config:set JWT_SECRET_KEY=your-production-secret
   
   # Deploy
   git push heroku main
   
   # Run migrations
   heroku run alembic upgrade head
   ```

2. **Procfile:**
   ```
   web: uvicorn main:app --host 0.0.0.0 --port $PORT
   ```

## Environment Configuration

### Production Environment Variables

```env
# Application
DEBUG=false
PROJECT_NAME="Your App Name"
API_V1_STR="/api/v1"

# Security
JWT_SECRET_KEY=your-very-secure-secret-key-here
CORS_ORIGINS=https://your-frontend-domain.com

# Database
POSTGRES_SERVER=your-db-host
POSTGRES_PORT=5432
POSTGRES_USER=your-db-user
POSTGRES_PASSWORD=your-secure-db-password
POSTGRES_DB=your-db-name

# Redis
REDIS_HOST=your-redis-host
REDIS_PORT=6379
REDIS_PASSWORD=your-redis-password

# Logging
LOG_DIRECTORY=/var/log/app
SERVICE_NAME=your-app-name
```

## Security Considerations

### Production Security Checklist

- [ ] **JWT Secret**: Use a strong, unique JWT secret key
- [ ] **CORS**: Restrict CORS origins to your domains only
- [ ] **HTTPS**: Always use HTTPS in production
- [ ] **Database**: Use strong database passwords and restrict access
- [ ] **Environment Variables**: Never commit secrets to version control
- [ ] **Rate Limiting**: Implement rate limiting on API endpoints
- [ ] **Input Validation**: Validate all input data
- [ ] **Logging**: Implement comprehensive logging for security monitoring
- [ ] **Updates**: Keep dependencies updated
- [ ] **Backups**: Set up regular database backups

### Monitoring and Health Checks

1. **Health check endpoint** (already included):
   ```python
   @app.get("/health")
   async def health_check():
       return {"status": "healthy"}
   ```

2. **Application monitoring:**
   ```bash
   # Add to requirements.txt
   prometheus-client==0.17.1
   ```

3. **Log monitoring:**
   - Use centralized logging (ELK stack, CloudWatch, etc.)
   - Set up alerts for error patterns
   - Monitor application performance metrics

### Backup Strategy

1. **Database backups:**
   ```bash
   # Automated backup script
   #!/bin/bash
   pg_dump -h $POSTGRES_SERVER -U $POSTGRES_USER $POSTGRES_DB | gzip > backup_$(date +%Y%m%d_%H%M%S).sql.gz
   ```

2. **Application backups:**
   - Version control for code
   - Environment configuration backups
   - SSL certificate backups

This deployment guide provides comprehensive instructions for various deployment scenarios. Choose the approach that best fits your infrastructure and requirements.